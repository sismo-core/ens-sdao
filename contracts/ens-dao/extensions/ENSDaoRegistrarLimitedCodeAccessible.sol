pragma solidity >=0.8.4;

import {ENSDaoRegistrarLimited} from './ENSDaoRegistrarLimited.sol';
import {IENSDaoRegistrarLimitedCodeAccessible} from './IENSDaoRegistrarLimitedCodeAccessible.sol';

import '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';

abstract contract ENSDaoRegistrarLimitedCodeAccessible is
  ENSDaoRegistrarLimited,
  IENSDaoRegistrarLimitedCodeAccessible
{
  using ECDSA for bytes32;

  mapping(bytes32 => bool) public _consumed;

  struct EIP712Domain {
    string name;
    string version;
    uint256 chainId;
    address verifyingContract;
  }

  struct CodeOrigin {
    address recipient;
    uint256 groupId;
  }

  bytes32 constant EIP712DOMAIN_TYPEHASH =
    keccak256(
      'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'
    );
  bytes32 constant CODE_ORIGIN_TYPEHASH =
    keccak256('CodeOrigin(address recipient,uint256 groupId)');

  bytes32 immutable DOMAIN_SEPARATOR;

  /**
   * @dev Constructor.
   * @param name The name field of the EIP712 Domain.
   * @param version The version field of the EIP712 Domain.
   */
  constructor(string memory name, string memory version) {
    DOMAIN_SEPARATOR = _hash(
      EIP712Domain({
        name: name,
        version: version,
        chainId: block.chainid,
        verifyingContract: address(this)
      })
    );
  }

  /**
   * @notice Register a name and mints a DAO token using an access code.
   * @dev Can only be called by the recipient of the access code generated by the owner.
   * @param label The label to register.
   * @param accessCode The EIP712 signature corresponding to a groupId and the recipient address.
   */
  function registerWithAccessCode(string memory label, bytes memory accessCode)
    external
    override
  {
    uint256 groupId = _getCurrentGroupId();

    CodeOrigin memory codeOrigin = CodeOrigin({
      recipient: _msgSender(),
      groupId: groupId
    });
    bytes32 digest = DOMAIN_SEPARATOR.toTypedDataHash(_hash(codeOrigin));

    require(
      !_consumed[digest],
      'ENS_DAO_REGISTRAR_LIMITED_CODE_ACCESSIBLE: ACCESS_CODE_ALREADY_CONSUMED'
    );

    require(
      digest.recover(accessCode) == owner(),
      'ENS_DAO_REGISTRAR_LIMITED_CODE_ACCESSIBLE: INVALID_ACCESS_CODE OR INVALID_SENDER'
    );

    if (_registrationLimit == _counter) {
      _updateRegistrationLimit(_registrationLimit + 1);
    }

    bytes32 labelHash = keccak256(bytes(label));
    _register(_msgSender(), label, labelHash);

    _consumed[digest] = true;

    emit AccessCodeConsumed(groupId, accessCode);
  }

  /**
   * @dev Encode and hash an EIP712Domain structure.
   * @return The hash of the encoding of the EIP712Domain structure.
   */
  function _hash(EIP712Domain memory eip712Domain)
    internal
    pure
    returns (bytes32)
  {
    return
      keccak256(
        abi.encode(
          EIP712DOMAIN_TYPEHASH,
          keccak256(bytes(eip712Domain.name)),
          keccak256(bytes(eip712Domain.version)),
          eip712Domain.chainId,
          eip712Domain.verifyingContract
        )
      );
  }

  /**
   * @dev Encode and hash an CodeOrigin structure.
   * @return The hash of the encoding of the CodeOrigin structure.
   */
  function _hash(CodeOrigin memory codeOrigin) internal pure returns (bytes32) {
    return
      keccak256(
        abi.encode(
          CODE_ORIGIN_TYPEHASH,
          codeOrigin.recipient,
          codeOrigin.groupId
        )
      );
  }

  /**
   * @dev Get the current group ID.
   * @return The current group ID.
   */
  function _getCurrentGroupId() internal virtual returns (uint256);
}
