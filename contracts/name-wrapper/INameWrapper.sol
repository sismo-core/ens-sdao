pragma solidity ^0.8.4;

import '@ensdomains/ens-contracts/contracts/registry/ENS.sol';
import '@ensdomains/ens-contracts/contracts/ethregistrar/BaseRegistrar.sol';
import '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';
import './IMetadataService.sol';

uint96 constant CANNOT_UNWRAP = 1;
uint96 constant CANNOT_BURN_FUSES = 2;
uint96 constant CANNOT_TRANSFER = 4;
uint96 constant CANNOT_SET_RESOLVER = 8;
uint96 constant CANNOT_SET_TTL = 16;
uint96 constant CANNOT_CREATE_SUBDOMAIN = 32;
uint96 constant CANNOT_REPLACE_SUBDOMAIN = 64;
uint96 constant CAN_DO_EVERYTHING = 0;

interface INameWrapper is IERC1155 {
  enum NameSafety {
    Safe,
    RegistrantNotWrapped,
    ControllerNotWrapped,
    SubdomainReplacementAllowed,
    Expired
  }
  event NameWrapped(
    bytes32 indexed node,
    bytes name,
    address owner,
    uint96 fuses
  );

  event NameUnwrapped(bytes32 indexed node, address owner);

  event FusesBurned(bytes32 indexed node, uint96 fuses);

  function ens() external view returns (ENS);

  function registrar() external view returns (BaseRegistrar);

  function metadataService() external view returns (IMetadataService);

  function names(bytes32) external view returns (bytes memory);

  function wrap(
    bytes calldata name,
    address wrappedOwner,
    uint96 _fuses,
    address resolver
  ) external;

  function wrapETH2LD(
    string calldata label,
    address wrappedOwner,
    uint96 _fuses,
    address resolver
  ) external;

  function registerAndWrapETH2LD(
    string calldata label,
    address wrappedOwner,
    uint256 duration,
    address resolver,
    uint96 _fuses
  ) external returns (uint256 expires);

  function renew(uint256 labelHash, uint256 duration)
    external
    returns (uint256 expires);

  function unwrap(
    bytes32 node,
    bytes32 label,
    address owner
  ) external;

  function unwrapETH2LD(
    bytes32 label,
    address newRegistrant,
    address newController
  ) external;

  function burnFuses(bytes32 node, uint96 _fuses) external;

  function setSubnodeRecord(
    bytes32 node,
    bytes32 label,
    address owner,
    address resolver,
    uint64 ttl
  ) external;

  function setSubnodeRecordAndWrap(
    bytes32 node,
    string calldata label,
    address owner,
    address resolver,
    uint64 ttl,
    uint96 _fuses
  ) external;

  function setRecord(
    bytes32 node,
    address owner,
    address resolver,
    uint64 ttl
  ) external;

  function setSubnodeOwner(
    bytes32 node,
    bytes32 label,
    address owner
  ) external returns (bytes32);

  function setSubnodeOwnerAndWrap(
    bytes32 node,
    string calldata label,
    address newOwner,
    uint96 _fuses
  ) external returns (bytes32);

  function isTokenOwnerOrApproved(bytes32 node, address addr)
    external
    returns (bool);

  function setResolver(bytes32 node, address resolver) external;

  function setTTL(bytes32 node, uint64 ttl) external;

  function getFuses(bytes32 node)
    external
    returns (
      uint96,
      NameSafety,
      bytes32
    );

  function allFusesBurned(bytes32 node, uint96 fuseMask)
    external
    view
    returns (bool);
}
